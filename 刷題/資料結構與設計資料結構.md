---
title: 資料結構與設計資料結構
tags:  
    - Linked List
    - Trie
    - Stack
    - Queue
    - hash table
categories: 
    - CS
    - Data Structure
comments: false
---


- array 
- linked list
資料遍歷
- 線性訪問 for/while
- 非線性訪問 遞迴

基本操作就是增刪查改，訪問方式迭代/遞迴
迭代與遞迴雖然時間複雜度都是O(N)，但是遞迴空間複雜度為O(N)，迭代則是O(1)


## quick sort vs merge sort
quick sort = preorder，這也說明了worse case 為什麼比merge sort差的原因
merge sort = postorder
```cpp
void sort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    int p = partition(nums, lo, hi);
    /************************/

    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}
```

```cpp
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
    /************************/
}
```

## Tips 
小知識
- 涉及到recursive，都可以視為樹的問題
- 很多動態規劃問題也是在拜訪一個樹
- 遞迴 其實就是stack概念

小訣竅
- 鏈接串列、子字串、數組題，用雙指針
- 快慢指針用於鏈接串列操作
- 左右指針用於數組操作，二元搜尋低一檔次
- 滑動窗口用於子字串

|    | 遞回 | 迭代 |
|--- | ----|-----|
| | 花費較多的時間、較無效率 | 執行時間較短|
| | 需要額外的 Stack 支持 | 不需要額外stack支持，但通常佔用儲存空間較大|
||  程式可讀性、較為精簡| 程式碼較冗長|
|| 易處理較複雜問題| |

two pointer 雙指標問題
    - slow fast 鏈接串列        
        - 環狀問題：第一次相遇後重置slow = head ，fast = 相遇點，再一起跑，這時快慢一致相遇點就是環狀起點。
    - left right pointer 數組 ：
        - Binary Search、變形的Binary Search
        - 數組 sum、數組 reverse、in-place 修改數組
        - Sliding window
    

* 刪除/搜尋 數組任意元素只要O(1)
    * 結合hash table 和 數組。hash插入搜尋刪除O(logn)  數組插入O(1)搜尋O(n)刪除O(n)
    * 關鍵在於刪除元素時，先把該元素交換到數組尾部，在pop掉

- 變形的Binary Search 找出自定義的函數，必須是單調遞減(遞增)函數、初始化left、right



## 進階區 - 資料結構基本題

## linked list

反轉linked list、反轉linked list前N個點、反轉linked list的一部分
- 206 Reverse Linked List(Easy)
- 92 Reverse Linked List II (Medium)
- 25 Reverse Nodes in k-Group (Hard)
- 234 Palindrome Linked List

補充
- 19 Remove Nth Node From End of List
- 21 Merge Two Sorted Lists
- 141 Linked List Cycle
- 142 Linked List Cycle II
- 2 Add Two Numbers






### 反轉linked list
#### 反轉linked list前N個點
```cpp
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
}
```

反轉linked list的一部分

```cpp
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}
```


#### 每K個一反轉
- 25 Reverse Nodes in k-Group(Hard)

基本反轉
```cpp
// 反转以 a 为头结点的链表
ListNode reverse(ListNode a) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    while (cur != null) {
        nxt = cur.next;
        // 逐个结点反转
        cur.next = pre;
        // 更新指针位置
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```
將 nll改成b
```cpp
/** 反转区间 [a, b) 的元素，注意是左闭右开 */
ListNode reverse(ListNode a, ListNode b) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    // while 终止的条件改一下就行了
    while (cur != b) {
        nxt = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}


ListNode reverseKGroup(ListNode head, int k) {
    if (head == null) return null;
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode a, b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) return head;
        b = b.next;
    }
    // 反转前 k 个元素
    ListNode newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
}
```
反轉區間` [a, b)`
#### 回文list
後序遍歷 （遞迴）
- 234 Palindrome Linked List

option 1 linked list的前序遍歷、後續遍歷

```cpp
// 左侧指针
ListNode left;

boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}

boolean traverse(ListNode right) {
    if (right == null) return true;
    boolean res = traverse(right.next);
    // 后序遍历代码
    res = res && (right.val == left.val);
    left = left.next;
    return res;
}
```
時間空間複雜度都是O(N)

option 2 two pointer 

## design data structure
- 130 Surrounded Regions (Medium)
- 990 Satisfiability of Equality Equations (Medium)
- 146 LRU Cache (Medium)
- 460 LFU Cache (Hard)
- 895 Maximum Frequency Stack (Hard)
- 295 Find Median from Data Stream (Hard)
- 355 Design Twitter (Medium)
- 496 Next Greater Element I (Easy)
- 503 Next Greater Element II (Medium)
- 739 Daily Temperatures (Medium)
- 239 Sliding Window Maximum (Hard)
- 232 Implement Queue using Stacks (Easy)
- 225 Implement Stack using Queues (Easy)
很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。

Monotonic Stack
基本問題：給一個陣列回傳一個陣列，對應著該索引存儲下一個更大的元素沒有則-1
變形：對於每一天，你還要等多少天才能等到更暖活的氣溫，如果等不到返回-1

```cpp
// monotonic stack
stack<int> sta;
vector<int> asc(nums2.size(),-1);

for(int i=nums2.size()-1;i>-1;--i){
    
    while(!sta.empty() && sta.top() <= nums2[i]){
        sta.pop();
    }
    
    asc[i] = sta.empty()?-1:sta.top();
    sta.push(nums2[i]);
}

```

Monotonic Queue 


```cpp
class MonotinicQueue{
private:
    list<int> q;
public:
    void push(int x){
        
        while(!q.empty() && q.back()<x){
            q.pop_back();
        }
        q.push_back(x);
    }
    void pop(int x){
        if(q.front() ==x){
            q.erase(q.begin());
        }
    }
    int max(){
        return q.front();
    }
};
```

[Union-Find](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/unionfind-suan-fa-xiang-jie)

Binary Heap 

Implement Queue using Stacks 需要兩個stack
Implement Stack using Queues 只需一個Queue

## array
- 870. Advantage Shuffle (Medium)
- 704 Binary Search(Easy)
- 34 Find First and Last Position of Element in Sorted Array(Medium)
- 875 Koko Eating Bananas (Medium)
- 1011 Capacity To Ship Packages Within D Days (Medium)
- 410 Split Array Largest Sum (Hard)
- 141 Linked List Cycle (Easy)
- 142 Linked List Cycle II (Medium)
- 876 Middle of the Linked List (Easy)
- 167 Two Sum II - Input array is sorted (Easy)
- 344 Reverse String (Easy)
- 19 Remove Nth Node From End of List (Medium)
- 76 Minimum Window Substring (Hard)
- 567 Permutation in String (Medium)
- 438 Find All Anagrams in a String (Medium)
- 3 Longest Substring Without Repeating Characters (Medium)
- 380 Insert Delete GetRandom O(1) (Medium)
- 710 Random Pick with Blacklist (Hard) 
- 316 Remove Duplicate Letters (Medium)
- 1081 Smallest Subsequence of Distinct Characters (Medium)
- 26 Remove Duplicates from Sorted Array (Easy)
- 83 Remove Duplicates from Sorted List (Easy)
- 27 Remove Element (Easy) 
- 283 Move Zeroes (Easy) 
- 1 Two Sum (Easy)
- 170 Two Sum III (Easy)


補充
- 349 Intersection of Two Arrays
- 350 Intersection of Two Arrays II
- 14 Longest Common Prefix
- 122 Best Time to Buy and Sell Stock II
- 189 Rotate Array
- 27 Remove Element
- 26 Remove Duplicates from Sorted Array
- 203 Remove Linked List Elements
- 80 Remove Duplicates from Sorted Array II
- 283 Move Zeroes
- 66 Plus One
- 1 Two Sum
- 15 3Sum
- 16 3Sum Closest
- 18 4Sum
- 6 ZigZag Conversion

補充string

- 344 Reverse String
- 387 First Unique Character in a String
- 125 Valid Palindrome
- 796 Rotate String
- 58 Length of Last Word
- 28 Implement strStr()





















## [contain](https://en.cppreference.com/w/cpp/container)
- Linked list

| algorithm | Average     | Worst case |
| --------- | ----------- | ---------- |
| space     | O(n)        | O(n)       |
| search    | O(n)        | O(n)       |
| insert    | O(1) begin  | O(n)       |
| delete    | O(1) begin  | O(n)       |

如果是doubly linked list ，end的插入、刪除也是O(1)

### [vector 陣列](https://zh.wikipedia.org/wiki/Vector_(STL))


* 存取方法 back front vec.at(i)/vec[i] data
* 修改器 push_back pop_back insert clear erase emplace_back emplace swap
* 容量 size empty resize reserve capacity shrink_to_fit
* 疊代 begin end rbegin rend cbegin cend crbegin crend

### [list](https://zh.wikipedia.org/wiki/List_(STL)) 雙向連結串列
* 存取方法 : back front 
* 修改器 : push_front/emplace_front pop_front push_back/emplace_back pop_back insert/emplace erase clear swap
* 容量 size empty resize 
* 疊代 begin end rbegin rend cbegin cend crbegin crend
* 其他操作 merge sort reverse remove/remove_if splice unique

### forward_list 才是 singly-linked list
* 存取方法 : front 
* 修改器 : push_front/emplace_front pop_front emplace_after insert_after erase_after swap clear
* 容量 resize empty 
* 疊代 begin end rbegin rend 
* 其他操作 merge sort reverse remove/remove_if splice_after unique

### array 
* 存取方法 : back front arr.at(i)/arr[i] data
* 容量 size empty 
* 疊代 begin end rbegin rend cbegin cend crbegin crend
* 其他操作 fill swap

### string 我不在container library 
存取方法 str.at(i)/str[i] front back data c_str substr
容量 size empty resize reserve length capacity 
修改器 push_back pop_back insert clear erase append copy replace swap +
find compare 
疊代 begin end rbegin rend cbegin cend crbegin crend


### Queue  可以array 、 linked list實現

| algorithm | Average | Worst case |
| --------- | ------- | ---------- |
| space     | O(n)    | O(n)       |
| search    | O(n)    | O(n)       |
| insert    | O(1)    | O(1)       |
| delete    | O(1)    | O(1)       |


* 常用方法 push pop front back size empty swap emplace
* back() front() push_back() pop_front()
### priority_queue 用vector 實作 但資料結構是 max-heap
* 常用方法 push pop top size empty swap emplace
* front() push_back() pop_back()
* heap 插入刪除元素時間 O(logn)

### deque
* 存取方法 deq.at(i)/deq[i] front back
* 容量 size empty resize max_size shrink_to_fit
* 修改器 push_back/emplace_back pop_back push_front/emplace_front pop_front insert/emplace clear erase swap 
* 疊代 begin end rbegin rend cbegin cend crbegin crend

### Stack 

| algorithm | Average | Worst case |
| --------- | ------- | ---------- |
| space     | O(k)    | O(k)       |
| search    | O(n)    | O(n)       |
| insert    | O(1)    | O(1)       |
| delete    | O(1)    | O(1)       |

* 常用方法 push pop top empty size swap emplace

### set   紅黑樹

| algorithm | Average | Worst case |
| --------- | ------- | ---------- |
| space     | O(n)    | O(n)       |
| search    | O(logN) | O(logN)    |
| insert    | O(logN) | O(logN)    |
| delete    | O(logN) | O(logN)    |


* 容量 size empty  max_size
* 修改器  insert clear erase swap  emplace emplace_hint merge extract 
* 疊代 begin end rbegin rend cbegin cend crbegin crend
* 查詢 count find equal_range lower_bound upper_bound contain


### unordered_set hash 結構

| algorithm | Average | Worst case   |
| --------- | ------- | ------------ |
| space     | O(n)    | O(n)         |
| search    | O(1)    | O(1) 分攤後  |
| insert    | O(1)    | O(1) 分攤後  |
| delete    | O(1)    | O(1)  分攤後 |



* 容量 size empty  max_size
* 修改器 insert clear erase swap emplace emplace_hint merge extract 
* 疊代 begin end cbegin cend 
* 查詢 count find equal_range contain

* hash方法 load_factor max_load_factor rehash reserve
* bucket 接口 begin/cbegin end/cend bucket_count max_bucket_count bucket_size bucket 
### map  紅黑樹

| algorithm | Average | Worst case |
| --------- | ------- | ---------- |
| space     | O(n)    | O(n)       |
| search    | O(logN) | O(n)       |
| insert    | O(logN) | O(1)       |
| delete    | O(logN) | O(1)       |


* 存取方法 deq.at(i)/deq[i] 
* 容量 size empty 
* 修改器  insert clear erase swap  emplace emplace_hint merge extract  insert_or_assign try_emplace
* 疊代 begin end rbegin rend cbegin cend crbegin crend
* 查詢 count find equal_range lower_bound upper_bound contain


### unordered_map hash 結構

| algorithm | Average | Worst case   |
| --------- | ------- | ------------ |
| space     | O(n)    | O(n)         |
| search    | O(1)    | O(1) 分攤後  |
| insert    | O(1)    | O(1) 分攤後  |
| delete    | O(1)    | O(1)  分攤後 |

* 存取方法 deq.at(i)/deq[i] 
* 容量 size empty max_size
* 修改器  insert clear erase swap  emplace emplace_hint merge extract  insert_or_assign try_emplace
* 疊代 begin end cbegin cend 
* 查詢 count find equal_range contain

* hash方法 load_factor max_load_factor rehash reserve
* bucket 接口 begin/cbegin end/cend bucket_count max_bucket_count bucket_size bucket 



### unordered_map vs. map and unordered_set vs set

unordered ，是無序的，
map set 資料訪問順序是按照插入順序而定。
例如 map 內部結構紅黑樹來實現，保證查詢、插入、刪除都是O（logN），最壞和平均都是
unordered_set  unordered_map 因為是hash template to comput hash ，所以不能拿pair tuple vector 來當key，但是map set 可以拿pair tuple vector 來當key，因為 map set 是通過操作符 `<` 比較大小，而pair是可以比較大小的

### summary
![](https://i.imgur.com/WwldmCl.png)

## sort

| case         | Bubble sort | insertion sort | selection sort | merge sort | quick sort | Radix Sort |
| ------------ | ----------- | -------------- | -------------- | ---------- | ---------- | ---------- |
| best case    | $N$         | $N$            | $N^2$          | $NlogN$    | $NlogN$    |      kN      |
| average case | $N^2$       | $N^2$          | $N^2$          | $NlogN$    | $NlogN$    |            |
| worst case   | $N^2$       | $N^2$          | $N^2$          | $NlogN$    | $N^2$      |            |
| Memory       | 1       | 1           | 1        | Depends    | logN   |            |



## search
- linear search
- binary search 
- exponential search
- junpsearch
- Interpolation search
- FibonacciSearch


## time compleity
- 陣列sum : O(n)
- 矩陣相加: O(n^2) 
- 矩陣相乘: O(n^3)
- 階層運算：O(n!)
- 指數時間：O(2^n)
- big O: upper bound
- big omega: lower bound
- big theta: tight bound
$1<logn<n<nlogn<n^2<n^3<2^n<n!$

```java

int f(int n){
    if(n<1) return 1;
    return f(n-1) + f(n-1);
}
// O(2^N)


(N-1) + (N-2) + (N-3) + ... + 2 + 1
// O(N^2)



int sum(Node node){
    if(node==nullptr) return 0;
    return sum(node.left) + node.val + sum(node.right);
}

// O(N) = O(2^(logN))


int factorial(int n){
    if(n<0) return -1;
    else if(n==0) return 1;
    else return n* factorial(n-1);
}

// O(n)

int fib(int n){
    if(n<=0) return 0;
    else if(n==1) return 1;
    return fib(n-1) +fib(n-2);
}
// O(2^N)
// but called n times is 
// O(2^(N+1)) = O(2^N)

int fib(int n , int []memo){
    if(n<0) return 0;
    else if(n==1) return 1;
    else if(memo[n]>0) return memo[n];
    
    memo[n] = fib(n-1, memo) + fib(n-2,memo);
    return memo[n];
}
// O(n)
```


## must-have knowledge


| Data Structures     | Algorithms           | Concepts             |
| ------------------- | -------------------- | -------------------- |
| Linked Lists        | Breadth-First Search | Bit Manipulation     |
| Tree,Tries & Graphs | Depth-First Search   | Memory(Stack & Heap) |
| Stack & Queues      | Binary Search        | Recursion            |
| Heaps               | Merge Sort           | Dynamic Programming  |
| Vectors/ArrayLists  | Quick Sort           | Big O Time & Space   |
| Hash tables         | Prefix Sum           |                      |
| skip list           |                      |                      |



