# 基本資料結構

###### tags: `interview` `algorithm`

- array 
- linked list
資料遍歷
- 線性訪問 for/while
- 非線性訪問 遞迴

基本操作就是增刪查改，訪問方式迭代/遞迴
迭代與遞迴雖然時間複雜度都是O(N)，但是遞迴空間複雜度為O(N)，迭代則是O(1)


## quick sort vs merge sort
quick sort = preorder，這也說明了worse case 為什麼比merge sort差的原因
merge sort = postorder
```cpp
void sort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    int p = partition(nums, lo, hi);
    /************************/

    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}
```

```cpp
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
    /************************/
}
```

## Tips 
小知識
- 涉及到recursive，都可以視為樹的問題
- 很多動態規劃問題也是在拜訪一個樹
- 遞迴 其實就是stack概念

小訣竅
- 鏈接串列、子字串、數組題，用雙指針
- 快慢指針用於鏈接串列操作
- 左右指針用於數組操作，二元搜尋低一檔次
- 滑動窗口用於子字串

|    | 遞回 | 迭代 |
|--- | ----|-----|
| | 花費較多的時間、較無效率 | 執行時間較短|
| | 需要額外的 Stack 支持 | 不需要額外stack支持，但通常佔用儲存空間較大|
||  程式可讀性、較為精簡| 程式碼較冗長|
|| 易處理較複雜問題| |



## 進階區 - 資料結構基本題

## linked list
### 反轉linked list
反轉linked list、反轉linked list前N個點、反轉linked list的一部分
- 206 Reverse Linked List(Easy)
- 92 Reverse Linked List II (Medium)
- 25 Reverse Nodes in k-Group (Hard)


反轉linked list前N個點
```cpp
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
}
```

反轉linked list的一部分

```cpp
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}
```


### 每K個一反轉
- 25 Reverse Nodes in k-Group(Hard)

基本反轉
```cpp
// 反转以 a 为头结点的链表
ListNode reverse(ListNode a) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    while (cur != null) {
        nxt = cur.next;
        // 逐个结点反转
        cur.next = pre;
        // 更新指针位置
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```
將 nll改成b
```cpp
/** 反转区间 [a, b) 的元素，注意是左闭右开 */
ListNode reverse(ListNode a, ListNode b) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    // while 终止的条件改一下就行了
    while (cur != b) {
        nxt = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}


ListNode reverseKGroup(ListNode head, int k) {
    if (head == null) return null;
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode a, b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) return head;
        b = b.next;
    }
    // 反转前 k 个元素
    ListNode newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
}
```
反轉區間` [a, b)`
#### 回文list
後序遍歷 （遞迴）
- 234 Palindrome Linked List

option 1 linked list的前序遍歷、後續遍歷

```cpp
// 左侧指针
ListNode left;

boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}

boolean traverse(ListNode right) {
    if (right == null) return true;
    boolean res = traverse(right.next);
    // 后序遍历代码
    res = res && (right.val == left.val);
    left = left.next;
    return res;
}
```
時間空間複雜度都是O(N)

option 2 two pointer 

## design data structure
- 130 Surrounded Regions (Medium)
- 990 Satisfiability of Equality Equations (Medium)
- 146 LRU Cache (Medium)
- 460 LFU Cache (Hard)
- 895 Maximum Frequency Stack (Hard)
- 295 Find Median from Data Stream (Hard)
- 355 Design Twitter (Medium)
- 496 Next Greater Element I (Easy)
- 503 Next Greater Element II (Medium)
- 739 Daily Temperatures (Medium)
- 239 Sliding Window Maximum (Hard)
- 232 Implement Queue using Stacks (Easy)
- 225 Implement Stack using Queues (Easy)
很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。

Monotonic Stack
基本問題：給一個陣列回傳一個陣列，對應著該索引存儲下一個更大的元素沒有則-1
變形：對於每一天，你還要等多少天才能等到更暖活的氣溫，如果等不到返回-1

```cpp
// monotonic stack
stack<int> sta;
vector<int> asc(nums2.size(),-1);

for(int i=nums2.size()-1;i>-1;--i){
    
    while(!sta.empty() && sta.top() <= nums2[i]){
        sta.pop();
    }
    
    asc[i] = sta.empty()?-1:sta.top();
    sta.push(nums2[i]);
}

```

Monotonic Queue 


```cpp
class MonotinicQueue{
private:
    list<int> q;
public:
    void push(int x){
        
        while(!q.empty() && q.back()<x){
            q.pop_back();
        }
        q.push_back(x);
    }
    void pop(int x){
        if(q.front() ==x){
            q.erase(q.begin());
        }
    }
    int max(){
        return q.front();
    }
};
```

[Union-Find](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/unionfind-suan-fa-xiang-jie)

Binary Heap 

Implement Queue using Stacks 需要兩個stack
Implement Stack using Queues 只需一個Queue

## array
- 870. Advantage Shuffle (Medium)
- 704 Binary Search(Easy)
- 34 Find First and Last Position of Element in Sorted Array(Medium)
- 875 Koko Eating Bananas (Medium)
- 1011 Capacity To Ship Packages Within D Days (Medium)
- 410 Split Array Largest Sum (Hard)
- 141 Linked List Cycle (Easy)
- 142 Linked List Cycle II (Medium)
- 876 Middle of the Linked List (Easy)
- 167 Two Sum II - Input array is sorted (Easy)
- 344 Reverse String (Easy)
- 19 Remove Nth Node From End of List (Medium)
- 76 Minimum Window Substring (Hard)
- 567 Permutation in String (Medium)
- 438 Find All Anagrams in a String (Medium)
- 3 Longest Substring Without Repeating Characters (Medium)
- 380 Insert Delete GetRandom O(1) (Medium)
- 710 Random Pick with Blacklist (Hard) 
- 316 Remove Duplicate Letters (Medium)
- 1081 Smallest Subsequence of Distinct Characters (Medium)
- 26 Remove Duplicates from Sorted Array (Easy)
- 83 Remove Duplicates from Sorted List (Easy)
- 27 Remove Element (Easy) 
- 283 Move Zeroes (Easy) 
- 1 Two Sum (Easy)
- 170 Two Sum III (Easy)


two pointer 雙指標問題
    - slow fast 鏈接串列        
        - 環狀問題：第一次相遇後重置slow = head ，fast = 相遇點，再一起跑，這時快慢一致相遇點就是環狀起點。
    - left right pointer 數組 ：
        - Binary Search、變形的Binary Search
        - 數組 sum、數組 reverse、in-place 修改數組
        - Sliding window
    

* 刪除/搜尋 數組任意元素只要O(1)
    * 結合hash table 和 數組。hash插入搜尋刪除O(logn)  數組插入O(1)搜尋O(n)刪除O(n)
    * 關鍵在於刪除元素時，先把該元素交換到數組尾部，在pop掉

- 變形的Binary Search 找出自定義的函數，必須是單調遞減(遞增)函數、初始化left、right


