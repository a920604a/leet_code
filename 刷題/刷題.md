# 刷題

###### tags: `interview` `algorithm`

## 目錄
870

## 基礎
### linked list
- 206 Reverse Linked List(Easy)
- 92 Reverse Linked List II (Medium)
- 25 Reverse Nodes in k-Group (Hard)
- 234 Palindrome Linked List

### Binary Tree
- 226 Invert Binary Tree (Easy)
- 114 Flatten Binary Tree to Linked List (Medium)
- 116 Populating Next Right Pointers in Each Node (Medium)
- 654 Maximum Binary Tree (Medium)
- 105 Construct Binary Tree from Preorder and Inorder Traversal (Medium)
- 106 Construct Binary Tree from Inorder and Postorder Traversal (Medium)
- 652 Find Duplicate Subtrees (Medium)




### Binary Search Tree
- 230 Kth Smallest Element in a BST (Medium)
- 538 Convert BST to Greater Tree (Medium)
- 1038 Binary Search Tree to Greater Sum Tree (Medium)
- 450 Delete Node in a BST (Medium)
- 701 Insert into a Binary Search Tree (Medium)
- 700 Search in a Binary Search Tree (Easy)
- 98 Validate Binary Search Tree (Medium)
- 96 Unique Binary Search Trees (Medium)
- 95 Unique Binary Search Trees II (Medium)
- 797 All Paths From Source to Target (Medium)
- 1373 Maximum Sum BST in Binary Tree (Hard)
- *297 Serialize and Deserialize Binary Tree (Hard)
- *341 Flatten Nested List Iterator (Medium)
- 236 Lowest Common Ancestor of a Binary Tree (Medium)
- 222 Count Complete Tree Nodes (Medium)

### Design data structure
- 130 Surrounded Regions (Medium)
- 990 Satisfiability of Equality Equations (Medium)
- 146 LRU Cache (Medium)
- *460 LFU Cache (Hard) 
- 895 Maximum Frequency Stack (Hard)
- 295 Find Median from Data Stream (Hard)
- 355 Design Twitter (Medium)
- 496 Next Greater Element I (Easy)
- 503 Next Greater Element II (Medium)
- 739 Daily Temperatures (Medium)
- 239 Sliding Window Maximum (Hard)
- 232 Implement Queue using Stacks (Easy)
- 225 Implement Stack using Queues (Easy)

### Array
- 870 Advantage Shuffle (Medium)
- 141 Linked List Cycle (Easy)
- 142 Linked List Cycle II (Medium)
- 876 Middle of the Linked List (Easy)
- 167 Two Sum II - Input array is sorted (Easy)
- 344 Reverse String (Easy)
- 19 Remove Nth Node From End of List (Medium)
- 380 Insert Delete GetRandom O(1) (Medium)
- 710 Random Pick with Blacklist (Hard) 
- 316 Remove Duplicate Letters (Medium)
- 1081 Smallest Subsequence of Distinct Characters (Medium)
- 26 Remove Duplicates from Sorted Array (Easy)
- 83 Remove Duplicates from Sorted List (Easy)
- 27 Remove Element (Easy) 
- 283 Move Zeroes (Easy) 
- 1 Two Sum (Easy)
- 170 Two Sum III (Easy)
- 350 Intersection of Two Arrays II


### Sliding window
- 76 Minimum Window Substring (Hard)
- 567 Permutation in String (Medium)
- 438 Find All Anagrams in a String (Medium)
- 3 Longest Substring Without Repeating Characters (Medium)
- 632 Smallest Range Covering Elements from K Lists (Hard)

### Binary Search
- 704 Binary Search(Easy)
- 34 Find First and Last Position of Element in Sorted Array(Medium)
- 875 Koko Eating Bananas (Medium)
- 1011 Capacity To Ship Packages Within D Days (Medium)
- 410 Split Array Largest Sum (Hard)

### 區間問題
- 56 Merge Intervals (Medium)
- 986 Interval List Intersections (Medium)
- 1288 Remove Covered Intervals (Medium)

### nSum 問題
- 15 3Sum (Medium)
- 18 4Sum (Medium)
- 454 4Sum (Medium)

### 動態規劃基本問題
- 509 Fibonacci Number (Easy 遞迴暴力求解、備忘錄優化、動態規劃求解)
- 322 Coin Change (Medium)
- 931 Minimum Falling Path Sum (Medium)
- 494 Target Sum (Medium)



### 子序列問題
- 72 Edit Distance (Hard)
- 300 Longest Increasing Subsequence (Medium) 
- 354 Russian Doll Envelopes (Hard)
- 53 Maximum Subarray (Easy) 
- 1143 Longest Common Subsequence (Medium)
- 583 Delete Operation for Two Strings (Medium)
- 712 Minimum ASCII Delete Sum for Two Strings (Medium)
- 516 Longest Palindromic Subsequence (Medium)


### 背包問題
- 416 Partition Equal Subset Sum (Medium)
- 518 Coin Change 2 (Medium)

### 貪心問題
- 453 Minimum Moves to Equal Array Elements (Easy)
- 435 Non-overlapping Intervals (Medium)
- 452 Minimum Number of Arrows to Burst Balloons (Medium)
- 1024 Video Stitching (Medium)
- 55 Jump Game (Medium)
- 45 Jump Game II (Medium)
- 134 Gas Station (Medium)


### 遊戲問題
- 64 Minimum Path Sum (Medium)
- 174 Dungeon Game (Hard)
- 514 Freedom Trail (Hard)
- 787 Cheapest Flights Within K Stops (Medium) 
- *10 Regular Expression Matching (Hard)
- 887 Super Egg Drop (Hard)
- 312 Burst Balloons (Hard)
- 877 Stone Game (Medium)
- 651 4 Keys Keyboard (Medium)
- 121 Best Time to Buy and Sell Stock (Easy)
- 188 Best Time to Buy and Sell Stock IV (Hard)
* 122 Best Time to Buy and Sell Stock II (Easy)
* 123 Best Time to Buy and Sell Stock III (Hard)
* 309 Best Time to Buy and Sell Stock with Cooldown (Medium)
* 714 Best Time to Buy and Sell Stock with Cooldown (Medium)
* 198 House Robber (Medium)
* 213 House Robber II (Medium)
* 337 House Robber III (Medium)
- 28 Implement strStr() (Easy)
- 1312 Minimum Insertion Steps to Make a String Palindrome (Hard)

### DFS/BFS
- 46 Permutations (Medium)
- 47 Permutations II (Medium)
- 51 N-Queens (Hard)
- 52 N-Queens (Hard) 
- 698 Partition to K Equal Sum Subsets (Medium)
- 78 Subsets (Medium)
- 45 Jump Game II (Medium)
- 77 Combinations (Medium)
- 37 Sudoku Solver (Hard)
- 22 Generate Parentheses (Medium)
- 111 Minimum Depth of Binary Tree (Easy)
- 752 Open the Lock (Medium)
- 773 Sliding Puzzle (Hard)

### Math
- 191 Number of 1 Bits (Easy)
- 231 Power of Two (Easy)
- 172 Factorial Trailing Zeroes (Easy)
- 793 Preimage Size of Factorial Zeroes Function (Hard)
- 204 Count Primes (Easy)
- 372 Super Pow (Medium)
- 448 Find All Numbers Disappeared in an Array (Easy)
- 654 Maximum Binary Tree (Medium)
- 382 Linked List Random Node (Medium)
- 398 Random Pick Index (Medium)
- 26 Remove Duplicates from Sorted Array (Easy)
- 83 Remove Duplicates from Sorted List (Easy)
- 27 Remove Element (Easy)
- 283 Move Zeroes (Easy)
- 292 Nim Game (Easy)
- 877 Stone Game (Medium)
- 319 Bulb Switcher (Medium)

### Other Algo 
- 560 Subarray Sum Equals K (Medium) 
- 1109 Corporate Flight Bookings (Medium) 
- 215 Kth Largest Element in an Array (Medium) 
- *241 Different Ways to Add Parentheses (Medium) 

### 高頻面試
- 659 Split Array into Consecutive Subsequences (Medium)
- 969 Pancake Sorting (Medium)
- 43 Multiply Strings (Medium)
- 224 Basic Calculator (Hard)
- 227 Basic Calculator II (Medium)
- 772 Basic Calculator III (Hard)
- 42 Trapping Rain Water (Hard)
- 5 Longest Palindromic Substring (Medium)
- 20 Valid Parentheses (Easy)
- 921 Minimum Add to Make Parentheses Valid (Medium)
- 1541 Minimum Insertions to Balance a Parentheses String  (Medium)
- 391 Perfect Rectangle (Hard)
- 855 Exam Room (Medium)
- 392 Is Subsequence (Easy)

### graph
- 207 Course Schedule (Medium)
- 210 Course Schedule II (Medium)
- 133 Clone Graph (Medium)
- 787 Cheapest Flights Within K Stops (Medium) 
- 797 All Paths From Source to Target (Medium) 

## 好用的框架 summary 
字串的子序列或是匹配問題直接就上**動態規劃**
遇到需要求出所有可能況狀首先考慮用**遞迴**。
x^0 = 0, x^x = 0, xor滿足交換率
雙指針分為 **快慢指針和左右指針**，快慢指針主要解決linked list問題，比如linked list是否有環，左右指針主要解決數組或字串問題，例如二元搜尋
快慢指針 判斷linked list是否有環、鏈表的環的起點、鏈表中點、鏈表中特定位置元素
左右指針 二元搜尋、兩數之和、反轉數組、移動窗口、子字串問題



### Dynamic programming

```cpp
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

###  Backtracking
```cpp
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

// 回溯算法關注的不是節點，而是樹枝

```

### BFS 

```cpp

// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

###  樹的遍歷
```cpp

/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}


```
###  Binary search

```cpp

int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```


###  Sliding Window

```cpp
int left = 0, right = 0;

while (right < s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

###  Binary Search Tree
```cpp
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

###  Graph traverse


```cpp
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;

    for (TreeNode child : root.children)
        traverse(child);
}

// 有環的圖
Graph graph;
boolean[] visited;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s
    visited[s] = true;
    for (TreeNode neighbor : graph.neighbors(s))
        traverse(neighbor);
    // 离开节点 s
    visited[s] = false;   
}
// 有向圖含有環的時候才需要 visited 數組輔助。
// 如果沒有環，連visited 都可以省略了，等同於樹的遍歷
```




## 參考資料
- [算法中文手冊](https://github.com/labuladong/fucking-algorithm)
- [hello-algorithm](https://github.com/geekxh/hello-algorithm)