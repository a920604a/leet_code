# 刷題

###### tags: `interview` `algorithm`
[toc]

## 基本資料結構
- array 
- linked list
資料遍歷
- 線性訪問 for/while
- 非線性訪問 遞迴

基本操作就是增刪查改，訪問方式迭代/遞迴
迭代與遞迴雖然時間複雜度都是O(N)，但是遞迴空間複雜度為O(N)，迭代則是O(1)

小知識
- 涉及到recursive，都可以視為樹的問題
- 很多動態規劃問題也是在拜訪一個樹
- 遞迴 其實就是stack概念
## 新手區 - 必讀
### 動態規劃
 一般形式就是求極值，核心思想是窮舉 + 重疊子問題。狀態、選擇、base case
- 509 Fibonacci Number (Easy 遞迴暴力求解、備忘錄優化、動態規劃求解)
- 322 Coin Change (Medium)
**動態規劃抽象框架**
```cpp=
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

### Backtracking 
本質上是DFS 決策樹的遍歷過程。所以算是暴力求解。路徑、當前選擇、結束條件。O(logN)
- 46 Permutations 
- 51 N-Queens

**Backtracking抽象框架**
```cpp=
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
### BFS 
找到路徑肯定是最短的，但代價就是空間複雜度比DFS大很多。用queue 輔助。O(N)
- 111 Minimum Depth of Binary Tree
- 752 Open the Lock

```cpp=
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数或是樹的深度

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```
### Binary Search
O(logN)，想法簡單，細節是魔鬼。溢位、mid是加一減一、while()用<= 還是<。
注意搜尋區間和while終止條件
搜尋左右邊界，只要修改`nums[mid] ==target` 條件處
- 704 Binary Search(Easy)
- 34 Find First and Last Position of Element in Sorted Array(Medium)

**Binary Search抽象框架**
```cpp=

int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}

int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) // 停止搜索
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}

```
- 盡量不要出現else，所有情況都寫清楚。
- 終止條件left == right
QA 
1. 為什麼 while 迴圈條件是`<=` 而不是 `<`
因為right ＝ nums.leagth-1 ，而不是nums.length，區別相當於：前者是`[left, right]`，後者是`[left, right)`，因為索引大小為nums.length是越界的。

也可以這樣寫
```cpp=
//...
while(left < right) {
    // ...
}
return nums[left] == target ? left : -1;
```

左側邊界的二元搜尋(較普及的寫法)
[1,2,2,2,3] 尋找所有２的位置
```cpp=
// option 1 
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意

    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}

// option 2 
int left_bound(int[] nums, int target) {
    // 搜索区间为 [left, right]
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        // if else ...
    
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }
    if (left >= nums.length || nums[left] != target) // 检查越界
        return -1;
    return left;
}
```
- 因為 `while(left< right)` ，終止條件`left == right`，搜尋區間 `[left, right)`
- 因為 搜尋區間 `[left, right)` ，會 分成兩區間 `[left, mid)` 和 `[mid+1, right)`
- 返回left 和 right 都一樣意思，因為終止條件是 left== right

右側邊界的二元搜尋
```cpp=

int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return left - 1; // 注意
}
```
- 因為終止條件是 left== right ， 所以return left-1 和 return right-1 都一樣。
- 因為left = mid + 1;  while迴圈結束時，nums[left] 一定不等於target，而nums[left-1]可能是target

統一左右兩側邊界的二元搜尋
```cpp=
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;   // 右側邊界
            // right = mid - 1; // 左側邊界
        }
    }
    // 这里改为检查 right 越界的情况，见下图
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```


### Sliding Window
two pointer 雙指針 O(N)
- 76 Minimum Window Substring(Hard)
- 567 Permutation in String(Medium)
- 438 Find All Anagrams in a String(Medium)
- 3 Longest Substring Without Repeating Characters(Medium)

```cpp=
int left = 0, right = 0;

while (right < s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```
### Leetcode 股票問題
利用狀態機。實際上 DP table
- 121 Best Time to Buy and Sell Stock (Easy)
- 188 Best Time to Buy and Sell Stock IV (Hard)
* 122 Best Time to Buy and Sell Stock II (Easy)
* 123 Best Time to Buy and Sell Stock III (Hard)
* 309 Best Time to Buy and Sell Stock with Cooldown (Medium)
* 714 Best Time to Buy and Sell Stock with Cooldown (Medium)

### Leetcode 打家劫舍問題
* 198 House Robber (Medium)
* 213 House Robber II (Medium)
* 337 House Robber III (Medium)

### 區間問題
本質上 就是線段問題，合併所有線段、找出線段的交集。可以用**排序、畫圖技巧**

* 56 Merge Intervals (Medium)
* 986 Interval List Intersections (Medium)
* 1288 Remove Covered Intervals (Medium)

三種狀況，全交集、部分交集、沒交集
### nSum 問題
**排序、雙指針**

- 15 3Sum (Medium)
- 18 4Sum (Medium)
- 454 4Sum (Medium)

```cpp=
vector<int> twoSum(vector<int>& nums, int target) {
    // 先对数组排序
    sort(nums.begin(), nums.end());
    // 左右指针
    int lo = 0, hi = nums.size() - 1;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 根据 sum 和 target 的比较，移动左右指针
        if (sum < target) {
            lo++;
        } else if (sum > target) {
            hi--;
        } else if (sum == target) {
            return {lo, hi};
        }
    }
    return {};
}
```

### Binary Tree
- 226 Invert Binary Tree (Easy)
- 114 Flatten Binary Tree to Linked List (Medium)
- 116 Populating Next Right Pointers in Each Node (Medium)

**快速排序是二元樹的前序遍歷，合併排序是二元樹的後序遍歷。**

寫有關於樹的演算法，或是說寫有關於遞迴演算法，關鍵一直都是必須搞清楚明確函數的定義是什麼，相信這個定義，不要跳入遞迴細節。
```cpp=
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

```cpp=
// 快速排序
void QuickSort(vector<int> &nums, int l, int r)
{

    if (l < r)
    {
        int pivot = Partition(nums, l, r);
        QuickSort(nums, l, pivot - 1);
        QuickSort(nums, pivot + 1, r);
    }
}

}
// 合併排序
void MergeSort(vector<int> &nums, int l, int r)
{

    if (l < r)
    {
        int mid = (l + r) / 2;
        MergeSort(nums, l, mid);
        MergeSort(nums, mid + 1, r);
        Merge(nums, l, mid, r);
    }
}
```

### 壓縮動態規劃
注意到dp[i][j] 都是由 dp[i-1][..] 轉移過來的，之前的數據都不需要了，所以可以將二維壓縮成一維，節省空間複雜度。
- 416 Partition Equal Subset Sum (Medium)


## 進階區 - 資料結構基本題

### linked list
#### 反轉linked list
反轉linked list、反轉linked list前N個點、反轉linked list的一部分
- 206 Reverse Linked List(Easy)
- 92 Reverse Linked List II (Medium)
- 25 Reverse Nodes in k-Group (Hard)


反轉linked list前N個點
```cpp=
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
}
```

反轉linked list的一部分

```cpp=
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}
```


#### 每K個一反轉
- 25 Reverse Nodes in k-Group(Hard)

基本反轉
```cpp=
// 反转以 a 为头结点的链表
ListNode reverse(ListNode a) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    while (cur != null) {
        nxt = cur.next;
        // 逐个结点反转
        cur.next = pre;
        // 更新指针位置
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```
將 nll改成b
```cpp=
/** 反转区间 [a, b) 的元素，注意是左闭右开 */
ListNode reverse(ListNode a, ListNode b) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    // while 终止的条件改一下就行了
    while (cur != b) {
        nxt = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}


ListNode reverseKGroup(ListNode head, int k) {
    if (head == null) return null;
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode a, b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) return head;
        b = b.next;
    }
    // 反转前 k 个元素
    ListNode newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
}
```
反轉區間` [a, b)`
#### 回文list
後序遍歷 （遞迴）
- 234 Palindrome Linked List

option 1 linked list的前序遍歷、後續遍歷

```cpp=
// 左侧指针
ListNode left;

boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}

boolean traverse(ListNode right) {
    if (right == null) return true;
    boolean res = traverse(right.next);
    // 后序遍历代码
    res = res && (right.val == left.val);
    left = left.next;
    return res;
}
```
時間空間複雜度都是O(N)

option 2 two pointer 

### binary tree
Binary tree
- 226 Invert Binary Tree (Easy)
- 114 Flatten Binary Tree to Linked List (Medium)
- 116 Populating Next Right Pointers in Each Node (Medium)
- 654 Maximum Binary Tree (Medium)
- 105 Construct Binary Tree from Preorder and Inorder Traversal (Medium)
- 106 Construct Binary Tree from Inorder and Postorder Traversal (Medium)
- 652 Find Duplicate Subtrees (Medium)

Binary Search Tree  BST 中序遍歷是有序的
- 230 Kth Smallest Element in a BST (Medium)
- 538 Convert BST to Greater Tree (Medium)
- 1038 Binary Search Tree to Greater Sum Tree (Medium)
- 450 Delete Node in a BST (Medium)
- 701 Insert into a Binary Search Tree (Medium)
- 700 Search in a Binary Search Tree (Easy)
- 98 Validate Binary Search Tree (Medium)
- 96 Unique Binary Search Trees (Medium)
- 95 Unique Binary Search Trees II (Medium)


- 797 All Paths From Source to Target (Medium)
- 1373 Maximum Sum BST in Binary Tree (Hard)
- 297 Serialize and Deserialize Binary Tree (Hard)
- 341 Flatten Nested List Iterator (Medium)
- 236 Lowest Common Ancestor of a Binary Tree (Medium)
- 222 Count Complete Tree Nodes (Medium)

BST**抽象框架**
```cpp=
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```
判斷 BST 的合法性

```cpp=

boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) 
        && isValidBST(root.right, root, max);
}
```
搜尋一個數
```cpp=
// option 1 brute force
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target) return true;
    // 当前节点没找到就递归地去左右子树寻找
    return isInBST(root.left, target)
        || isInBST(root.right, target);
}

// option 2 binary search 真正BST精神 
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target)
        return true;
    if (root.val < target) 
        return isInBST(root.right, target);
    if (root.val > target)
        return isInBST(root.left, target);
    // root 该做的事做完了，顺带把框架也完成了，妙
}
//  抽象出來
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```
插入一個數，涉及到“改”，就要返回樹的結構
```cpp=
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);
    // if (root.val == val)
    //     BST 中一般不会插入已存在元素
    if (root.val < val) 
        root.right = insertIntoBST(root.right, val);
    if (root.val > val) 
        root.left = insertIntoBST(root.left, val);
    return root;
}
```
刪除一個數，先“查“再”改“。找到後判斷是否有子節點，及是否破壞結構
```cpp=
// 抽象 框架
TreeNode deleteNode(TreeNode root, int key) {
    if (root.val == key) {
        // 找到啦，进行删除
    } else if (root.val > key) {
        // 去左子树找
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        // 去右子树找
        root.right = deleteNode(root.right, key);
    }
    return root;
}


TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        // 这两个 if 把情况 1 和 2 都正确处理了
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // 处理情况 3
        TreeNode minNode = getMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

TreeNode getMin(TreeNode node) {
    // BST 最左边的就是最小的
    while (node.left != null) node = node.left;
    return node;
}

```
建造最大二元樹

```cpp=
TreeNode constructMaximumBinaryTree(int[] nums) {
    if (nums is empty) return null;
    // 找到数组中的最大值
    int maxVal = Integer.MIN_VALUE;
    int index = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > maxVal) {
            maxVal = nums[i];
            index = i;
        }
    }

    TreeNode root = new TreeNode(maxVal);
    // 递归调用构造左右子树
    root.left = constructMaximumBinaryTree(nums[0..index-1]);
    root.right = constructMaximumBinaryTree(nums[index+1..nums.length-1]);
    return root;
}
```

不同的二元搜尋樹，求樹的數量、列出每棵樹
```cpp=

/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi) return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}

// 备忘录
int[][] memo;

int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    return count(1, n);
}

int count(int lo, int hi) {
    if (lo > hi) return 1;
    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }

    int res = 0;
    for (int mid = lo; mid <= hi; mid++) {
        int left = count(lo, mid - 1);
        int right = count(mid + 1, hi);
        res += left * right;
    }
    // 将结果存入备忘录
    memo[lo][hi] = res;

    return res;
}


/* 主函数 */
public List<TreeNode> generateTrees(int n) {
    if (n == 0) return new LinkedList<>();
    // 构造闭区间 [1, n] 组成的 BST 
    return build(1, n);
}

/* 构造闭区间 [lo, hi] 组成的 BST */
List<TreeNode> build(int lo, int hi) {
    List<TreeNode> res = new LinkedList<>();
    // base case
    if (lo > hi) {
        res.add(null);
        return res;
    }

    // 1、穷举 root 节点的所有可能。
    for (int i = lo; i <= hi; i++) {
        // 2、递归构造出左右子树的所有合法 BST。
        List<TreeNode> leftTree = build(lo, i - 1);
        List<TreeNode> rightTree = build(i + 1, hi);
        // 3、给 root 节点穷举所有左右子树的组合。
        for (TreeNode left : leftTree) {
            for (TreeNode right : rightTree) {
                // i 作为根节点 root 的值
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }

    return res;
}
```

Graph 圖，用adjacent linked list 、adjacent matrix 存儲

**遍歷圖的框架**

```cpp=
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;

    for (TreeNode child : root.children)
        traverse(child);
}

// 有環的圖
Graph graph;
boolean[] visited;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s
    visited[s] = true;
    for (TreeNode neighbor : graph.neighbors(s))
        traverse(neighbor);
    // 离开节点 s
    visited[s] = false;   
}
```
圖的所有路徑

```cpp=
// 记录所有路径
List<List<Integer>> res = new LinkedList<>();

public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    LinkedList<Integer> path = new LinkedList<>();
    traverse(graph, 0, path);
    return res;
}

/* 图的遍历框架 */
void traverse(int[][] graph, int s, LinkedList<Integer> path) {

    // 添加节点 s 到路径
    path.addLast(s);

    int n = graph.length;
    if (s == n - 1) {
        // 到达终点
        res.add(new LinkedList<>(path));
        path.removeLast();
        return;
    }

    // 递归每个相邻节点
    for (int v : graph[s]) {
        traverse(graph, v, path);
    }

    // 从路径移出节点 s
    path.removeLast();
}
```

二元搜尋數子樹的最大鍵值總和
1. 確認子樹合法性(BST左小右大)
2. 確認把自己加入是否還合法，比較左子樹最大值和柚子樹最小值
3. 左右子樹之和


### design data structure
- 130 Surrounded Regions (Medium)
- 990 Satisfiability of Equality Equations (Medium)
- 146 LRU Cache (Medium)
- 460 LFU Cache (Hard)
- 895 Maximum Frequency Stack (Hard)
- 295 Find Median from Data Stream (Hard)
- 355 Design Twitter (Medium)
- 496 Next Greater Element I (Easy)
- 503 Next Greater Element II (Medium)
- 739 Daily Temperatures (Medium)
- 239 Sliding Window Maximum (Hard)
- 232 Implement Queue using Stacks (Easy)
- 225 Implement Stack using Queues (Easy)
很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。

Monotonic Stack
基本問題：給一個陣列回傳一個陣列，對應著該索引存儲下一個更大的元素沒有則-1
變形：對於每一天，你還要等多少天才能等到更暖活的氣溫，如果等不到返回-1

Monotonic Queue 
Sliding window 
[Union-Find](https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-2/unionfind-suan-fa-xiang-jie)

Binary Heap

Implement Stack using Queues

### array
- 875 Koko Eating Bananas (Medium)
- 1011 Capacity To Ship Packages Within D Days (Medium)
- 410 Split Array Largest Sum (Hard)
- 141 Linked List Cycle (Easy)
- 142 Linked List Cycle II (Medium)
- 167 Two Sum II - Input array is sorted (Easy)
- 344 Reverse String (Easy)
- 19 Remove Nth Node From End of List (Medium)
- 76 Minimum Window Substring (Hard)
- 567 Permutation in String (Medium)
- 438 Find All Anagrams in a String (Medium)
- 3 Longest Substring Without Repeating Characters (Medium)
- 380 Insert Delete GetRandom O(1) (Medium)
- 710 Random Pick with Blacklist (Hard) 
- 316 Remove Duplicate Letters (Medium)
- 1081 Smallest Subsequence of Distinct Characters (Medium)
- 26 Remove Duplicates from Sorted Array (Easy)
- 83 Remove Duplicates from Sorted List (Easy)
- 27 Remove Element (Easy) 
- 283 Move Zeroes (Easy) 
- 1 Two Sum (Easy)
- 170 Two Sum III (Easy)


Binary Search
* slow fast 雙指標問題
    * 第一次相遇後重置slow = head ，fast = 相遇點，再一起跑，這時快慢一致相遇點就是環狀起點。

* 刪除/搜尋 數組任意元素只要O(1)
    * 結合hash table 和 數組。hash插入搜尋刪除O(logn)  數組插入O(1)搜尋O(n)刪除O(n)
    * 關鍵在於刪除元素時，先把該元素交換到數組尾部，在pop掉



## 進階區 - 動態規劃
### 動態規劃基本問題
動態規劃一般形式，求極值
- 509 Fibonacci Number (Easy)
- 322 Coin Change (Medium)
- 931 Minimum Falling Path Sum (Medium)
- 494 Target Sum (Medium)

### 子序列問題
- 72 Edit Distance (Hard)
- 300 Longest Increasing Subsequence (Medium) 
- 354 Russian Doll Envelopes (Hard)
- 53 Maximum Subarray (Easy) 
- 1143 Longest Common Subsequence (Medium)
- 583 Delete Operation for Two Strings (Medium)
- 712 Minimum ASCII Delete Sum for Two Strings (Medium)
- 516 Longest Palindromic Subsequence (Medium)
### 背包問題
- 416 Partition Equal Subset Sum (Medium)
- 518 Coin Change 2 (Medium)

### 貪心問題
- 453 Minimum Moves to Equal Array Elements (Easy)
- 452 Minimum Number of Arrows to Burst Balloons (Medium)
- 55 Jump Game (Medium)
- 45 Jump Game II (Medium)
### 遊戲問題
- 64 Minimum Path Sum (Medium)
- 174 Dungeon Game (Hard)
- 514 Freedom Trail (Hard)
- 10 Regular Expression Matching (Hard)
- 887 Super Egg Drop (Hard)
- 312 Burst Balloons (Hard)
- 877 Stone Game (Medium)
- 651 4 Keys Keyboard (Medium)
- 121 Best Time to Buy and Sell Stock (Easy)
- 188 Best Time to Buy and Sell Stock IV (Hard)
* 122 Best Time to Buy and Sell Stock II (Easy)
* 123 Best Time to Buy and Sell Stock III (Hard)
* 309 Best Time to Buy and Sell Stock with Cooldown (Medium)
* 714 Best Time to Buy and Sell Stock with Cooldown (Medium)
* 198 House Robber (Medium)
* 213 House Robber II (Medium)
* 337 House Robber III (Medium)
- 28 Implement strStr() (Easy)
- 1312 Minimum Insertion Steps to Make a String Palindrome (Hard)
## 進階區 - 其他必知必會

### backtracking/DFS
- 46 Permutations (Medium)
- 47 Permutations II (Medium)
- 51 N-Queens (Hard)
- 52 N-Queens (Hard) 
- 698 Partition to K Equal Sum Subsets (Medium)
- 78 Subsets (Medium)
- 45 Jump Game II (Medium)
- 77 Combinations (Medium)
- 37 Sudoku Solver (Hard)
- 22 Generate Parentheses (Medium)
### BFS
- 111 Minimum Depth of Binary Tree (Easy)
- 752 Open the Lock (Medium)
- 773 Sliding Puzzle (Hard)
### Math
- 191 Number of 1 Bits (Easy)
- 231 Power of Two (Easy)
- 172 Factorial Trailing Zeroes (Easy)
- 793 Preimage Size of Factorial Zeroes Function (Hard)
- 204 Count Primes (Easy)
- 372 Super Pow (Medium)
- 448 Find All Numbers Disappeared in an Array (Easy)
- 654 Maximum Binary Tree (Medium)
- 382 Linked List Random Node (Medium)
- 398 Random Pick Index (Medium)
- 26 Remove Duplicates from Sorted Array (Easy)
- 83 Remove Duplicates from Sorted List (Easy)
- 27 Remove Element (Easy)
- 283 Move Zeroes (Easy)
- 292 Nim Game (Easy)
- 877 Stone Game (Medium)
- 319 Bulb Switcher (Medium) 
### Other Algo
- 560 Subarray Sum Equals K (Medium) 
- 1109 Corporate Flight Bookings (Medium) 
- 215 Kth Largest Element in an Array (Medium) 
- 241 Different Ways to Add Parentheses (Medium) 
## 進階區 - 高頻面試題
- 659 Split Array into Consecutive Subsequences (Medium)
- 969 Pancake Sorting (Medium)
- 43 Multiply Strings (Medium)
- 224 Basic Calculator (Hard)
- 227 Basic Calculator II (Medium)
- 772 Basic Calculator III (Hard)
- 42 Trapping Rain Water (Hard)
- 5 Longest Palindromic Substring (Medium)
- 20 Valid Parentheses (Easy)
- 391 Perfect Rectangle (Hard)
- 855 Exam Room (Medium)
- 392 Is Subsequence (Easy)

## 好用的抽象框架 summary 
雙指針分為 快慢指針和左右指針，前者只要解決linked list問題，比如linked list是否有環，後者主要解決數組或字串問題，例如二元搜尋
快慢指針 判斷linked list是否有環、鏈表的環的起點、鏈表中點、鏈表中特定位置元素
左右指針 二元搜尋、兩數之和、反轉數組、移動窗口、子字串問題



Dynamic programming

```cpp=
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

Backtracking
```cpp=
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

樹的遍歷
```cpp=

/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}


```
Binary search

```cpp=

int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```


Sliding Window

```cpp=
int left = 0, right = 0;

while (right < s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

Binary Search Tree
```cpp=
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

Graph traverse


```cpp=
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;

    for (TreeNode child : root.children)
        traverse(child);
}

// 有環的圖
Graph graph;
boolean[] visited;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s
    visited[s] = true;
    for (TreeNode neighbor : graph.neighbors(s))
        traverse(neighbor);
    // 离开节点 s
    visited[s] = false;   
}
```




## 參考資料
- [算法中文手冊](https://github.com/labuladong/fucking-algorithm)